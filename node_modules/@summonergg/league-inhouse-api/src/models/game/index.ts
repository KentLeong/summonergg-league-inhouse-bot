import log from "chalk-logging";
import { API } from "../api";
// import * as randomize from "randomatic";
import { handleError } from "res-codes";
import { client, User } from "../../";
import Discord from "discord.js";
import { translate } from "../../modules";
import { en_US } from "../discord/translate/en_US";
import { LobbyBot } from "@summonergg/league-inhouse-lobby-client";
import { Summoner } from "@summonergg/riot-api";

export class Game extends API {
  host: string;
  players: Playerlol[];
  _id: string;
  state: string;
  map: string;
  draft: string;
  modes: Array<string>;
  region: any;
  server: string;
  blueTeam: Playerlol[];
  redTeam: Playerlol[];
  championPool: Array<object>;
  restrictor: Array<string>;
  bot: string;
  name: string;
  done: boolean;
  message: string;
  channel: string;
  maxPlayers: number;
  ranked: boolean;
  createdAt: Date;

  res?: TranslateResponse;
  msg?: DiscordMessage;
  clientType?: clientType;
  guild?: Discord.Guild;
  client?: Discord.Client;

  constructor(
    public opt?: apiOptions
  ) {
    super();
    if (opt?.msg) {
      this.msg = opt.msg;
      this.client = this.msg.client;
      this.guild = opt.msg.guild;
      this.res = translate(this.msg, "game");
    }
  }

  async displayLobby(): Promise<void> {
    var teams: any = {};
    if (this.blueTeam.length != 0 || this.redTeam.length != 0) {
      teams.one = "```";
      teams.two = "```";
      
      for (let i = 0; i < this.maxPlayers/2; i++) {
        if (this.blueTeam[i]) {
          teams.one += `${i+1}. ${this.blueTeam[i].account.name}\n`;
        } else {
          teams.one += `${i+1}.\n`
        }
      }
      teams.one.substring(0, teams.one.length - 2);
      teams.one += "```";

      for (let i = 0; i < this.maxPlayers/2; i++) {
        if (this.redTeam[i]) {
          teams.two += `${i+1}. ${this.redTeam[i].account.name}\n`;
        } else {
          teams.two += `${i+1}.\n`
        }
      }
      teams.two.substring(0, teams.two.length - 2);
      teams.two += "```";
    }

    var lobby: string[] = [];
    for (let i = 0; i < this.maxPlayers; i++) {
      if (this.players[i]) {
        var num = i;
        if (this.state == "drafting") num -= 2;
        var place = (num === 9) ? `${num+1}. ` : `${num+1}.  `;
        var ready = this.players[i].ready ? "✔️" : "❌";
        var name = `${this.players[i].account.name}`;
        var found = false;
        this.redTeam.forEach(p => {
          if (p.discordId == this.players[i].discordId) found = true;
        })
        this.blueTeam.forEach(p => {
          if (p.discordId == this.players[i].discordId) found = true;
        })
        if (!found) {
          (this.state == "drafting") ? lobby.push(place+name) : lobby.push(place+ready+name);
        }
      } else {
        lobby.push(`${i+1}. `)
      }
    }
    if (lobby.length !== 0) {
      lobby.unshift("```");
      lobby.push("```");
    }
    this.res(300, {
      lobby,
      teams,
      game: this
    });
  }

  async addPlayer(user: User): Promise<boolean> {
    if (this.players.length === this.maxPlayers) return this.res(200);
    var player: Playerlol = {
      account: user.accounts.lol[0],
      discordId: user.discordId,
      ready: false,
      roles: user.roles.lol,
      gold: user.gold,
      level: user.level,
      experience: user.experience
    }
    this.players.push(player);
    var account = user.accounts.lol[0];
    try {
      var bot: LobbyBot = await LobbyBot.connect(this.region.toUpperCase(), this.bot);
      var summoner: any = await Summoner.get({summonerId: account.id, region: this.region});
      await bot.invitePlayer(summoner.summonerId);
    } catch(err) {log.error(err)};
    
    await this.save();
    return true;
  }

  async playerReady(discordId: string): Promise<boolean> {
    return new Promise(async (resolve: any, reject: any) => {
      var found = false;
      this.players.forEach((player: Playerlol, i: number) => {
        if (player.discordId == discordId) {
          found = true;
          this.players[i].ready = true;
        }
      })
      await this.save();
      if (!found) reject();
      resolve(true);
    })
  }

  async removePlayer(user: User): Promise<boolean> {
    var found = false;
    var account = user.accounts.lol[0];
    this.players.forEach((player: Playerlol, i: number) => {
      if (player.discordId === user.discordId) {
        found = true;
        this.players.splice(i, 1);
      }
    })
    if (!found) this.res(201, {player: account.name});
    await this.save();
    return found;
  }

  async cancel() {
    var channel = await this.client.channels.fetch(this.channel) as Discord.TextChannel;
    var message = await channel.messages.fetch(this.message);
    if (message) await message.delete();
    await this.delete();
    this.res(100);
  }

  async isReady(): Promise<boolean> {
    if (this.maxPlayers !== this.players.length) {
      this.res(202);
      return false;
    }

    var ready = true;
    this.players.forEach(player => {
      if (!player.ready) ready = false;
    })
    if (!ready) this.res(203);
    return ready;
  }

  async sortPlayerELO() {
    this.players.sort((a: Playerlol, b: Playerlol) => {
      return b.account.elo - a.account.elo
    })
  }

  async startLobby() {
    await this.sortPlayerELO();
    this.state = "drafting";

    var captains = {
      cap1: {
        team: "",
        ...this.players[0]
      },
      cap2: {
        team: "",
        ...this.players[1]
      }
    }
    var players = this.players.slice(2, this.maxPlayers);
    var available: Set<string> = new Set();
    for (let i = 1; i <= this.maxPlayers-2; i++) available.add(i.toString());
    var u = await this.client.users.fetch(captains.cap2.discordId);

    this.res(350, {channel: this.msg.channel, user: u});
    if (this.msg) this.awaitResponse(captains, available, players, "init");
  }

  async awaitResponse(captains: Record<string, any>, available: Set<string>, players: Playerlol[], state: string) {
    if (state != "init") this.displayLobby();
    if (available.size == 0) {
      this.state = "draftFinished";
      this.save();
      return;
    }
    var filter;
    if (state === "init" || state === "cap2") {
      filter = (m: Discord.Message) => m.author.id === captains["cap2"].discordId;
    } else if (state === "cap1") {
      filter = (m: Discord.Message) => m.author.id === captains["cap1"].discordId;
    }
    var firstPick = ["fp", "first"];
    var secondPick = ["sp", "second"];
    var channel = await this.client.channels.fetch(this.channel) as Discord.TextChannel;
    const collecter = channel.createMessageCollector(filter);

    collecter.on("collect", async (m: Discord.Message)=> {
      var content = m.content.toLowerCase();
      if (state == "init") {
        if (firstPick.includes(content)) {
          this.blueTeam.push(this.players[1]);
          this.redTeam.push(this.players[0]);
          captains.cap1.team = "redTeam";
          captains.cap2.team = "blueTeam";
          await this.awaitResponse(captains, available, players, "cap2");
          collecter.stop();
        } else if (secondPick.includes(content)) {
          this.redTeam.push(this.players[1]);
          this.blueTeam.push(this.players[0]);
          captains.cap2.team = "redTeam";
          captains.cap1.team = "blueTeam";
          await this.awaitResponse(captains, available, players, "cap1");
          collecter.stop();
        }
      } else if (state == "cap1" || state == "cap2") {
        if (available.has(content)) {
          let index = (+content)-1;
          let team = captains[state].team as "blueTeam" | "redTeam";
          this[team].push(players[index]);
          available.delete(content);
          if (available.size % 2 == 0) {
            await this.awaitResponse(captains, available, players, state);
          } else if (state == "cap1") {
            await this.awaitResponse(captains, available, players, "cap2");
          } else if (state == "cap2") {
            await this.awaitResponse(captains, available, players, "cap1");
          }
          collecter.stop();
        }
      }
    });
  }
}