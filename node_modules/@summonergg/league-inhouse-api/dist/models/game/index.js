"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Game = void 0;
const tslib_1 = require("tslib");
const chalk_logging_1 = tslib_1.__importDefault(require("chalk-logging"));
const api_1 = require("../api");
const modules_1 = require("../../modules");
const league_inhouse_lobby_client_1 = require("@summonergg/league-inhouse-lobby-client");
const riot_api_1 = require("@summonergg/riot-api");
class Game extends api_1.API {
    constructor(opt) {
        super();
        this.opt = opt;
        if (opt === null || opt === void 0 ? void 0 : opt.msg) {
            this.msg = opt.msg;
            this.client = this.msg.client;
            this.guild = opt.msg.guild;
            this.res = modules_1.translate(this.msg, "game");
        }
    }
    displayLobby() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var teams = {};
            if (this.blueTeam.length != 0 || this.redTeam.length != 0) {
                teams.one = "```";
                teams.two = "```";
                for (let i = 0; i < this.maxPlayers / 2; i++) {
                    if (this.blueTeam[i]) {
                        teams.one += `${i + 1}. ${this.blueTeam[i].account.name}\n`;
                    }
                    else {
                        teams.one += `${i + 1}.\n`;
                    }
                }
                teams.one.substring(0, teams.one.length - 2);
                teams.one += "```";
                for (let i = 0; i < this.maxPlayers / 2; i++) {
                    if (this.redTeam[i]) {
                        teams.two += `${i + 1}. ${this.redTeam[i].account.name}\n`;
                    }
                    else {
                        teams.two += `${i + 1}.\n`;
                    }
                }
                teams.two.substring(0, teams.two.length - 2);
                teams.two += "```";
            }
            var lobby = [];
            for (let i = 0; i < this.maxPlayers; i++) {
                if (this.players[i]) {
                    var num = i;
                    if (this.state == "drafting")
                        num -= 2;
                    var place = (num === 9) ? `${num + 1}. ` : `${num + 1}.  `;
                    var ready = this.players[i].ready ? "✔️" : "❌";
                    var name = `${this.players[i].account.name}`;
                    var found = false;
                    this.redTeam.forEach(p => {
                        if (p.discordId == this.players[i].discordId)
                            found = true;
                    });
                    this.blueTeam.forEach(p => {
                        if (p.discordId == this.players[i].discordId)
                            found = true;
                    });
                    if (!found) {
                        (this.state == "drafting") ? lobby.push(place + name) : lobby.push(place + ready + name);
                    }
                }
                else {
                    lobby.push(`${i + 1}. `);
                }
            }
            if (lobby.length !== 0) {
                lobby.unshift("```");
                lobby.push("```");
            }
            this.res(300, {
                lobby,
                teams,
                game: this
            });
        });
    }
    addPlayer(user) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.players.length === this.maxPlayers)
                return this.res(200);
            var player = {
                account: user.accounts.lol[0],
                discordId: user.discordId,
                ready: false,
                roles: user.roles.lol,
                gold: user.gold,
                level: user.level,
                experience: user.experience
            };
            this.players.push(player);
            var account = user.accounts.lol[0];
            try {
                var bot = yield league_inhouse_lobby_client_1.LobbyBot.connect(this.region.toUpperCase(), this.bot);
                var summoner = yield riot_api_1.Summoner.get({ summonerId: account.id, region: this.region });
                yield bot.invitePlayer(summoner.summonerId);
            }
            catch (err) {
                chalk_logging_1.default.error(err);
            }
            ;
            yield this.save();
            return true;
        });
    }
    playerReady(discordId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var found = false;
                this.players.forEach((player, i) => {
                    if (player.discordId == discordId) {
                        found = true;
                        this.players[i].ready = true;
                    }
                });
                yield this.save();
                if (!found)
                    reject();
                resolve(true);
            }));
        });
    }
    removePlayer(user) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var found = false;
            var account = user.accounts.lol[0];
            this.players.forEach((player, i) => {
                if (player.discordId === user.discordId) {
                    found = true;
                    this.players.splice(i, 1);
                }
            });
            if (!found)
                this.res(201, { player: account.name });
            yield this.save();
            return found;
        });
    }
    cancel() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var channel = yield this.client.channels.fetch(this.channel);
            var message = yield channel.messages.fetch(this.message);
            if (message)
                yield message.delete();
            yield this.delete();
            this.res(100);
        });
    }
    isReady() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.maxPlayers !== this.players.length) {
                this.res(202);
                return false;
            }
            var ready = true;
            this.players.forEach(player => {
                if (!player.ready)
                    ready = false;
            });
            if (!ready)
                this.res(203);
            return ready;
        });
    }
    sortPlayerELO() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.players.sort((a, b) => {
                return b.account.elo - a.account.elo;
            });
        });
    }
    startLobby() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.sortPlayerELO();
            this.state = "drafting";
            var captains = {
                cap1: Object.assign({ team: "" }, this.players[0]),
                cap2: Object.assign({ team: "" }, this.players[1])
            };
            var players = this.players.slice(2, this.maxPlayers);
            var available = new Set();
            for (let i = 1; i <= this.maxPlayers - 2; i++)
                available.add(i.toString());
            var u = yield this.client.users.fetch(captains.cap2.discordId);
            this.res(350, { channel: this.msg.channel, user: u });
            if (this.msg)
                this.awaitResponse(captains, available, players, "init");
        });
    }
    awaitResponse(captains, available, players, state) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (state != "init")
                this.displayLobby();
            if (available.size == 0) {
                this.state = "draftFinished";
                this.save();
                return;
            }
            var filter;
            if (state === "init" || state === "cap2") {
                filter = (m) => m.author.id === captains["cap2"].discordId;
            }
            else if (state === "cap1") {
                filter = (m) => m.author.id === captains["cap1"].discordId;
            }
            var firstPick = ["fp", "first"];
            var secondPick = ["sp", "second"];
            var channel = yield this.client.channels.fetch(this.channel);
            const collecter = channel.createMessageCollector(filter);
            collecter.on("collect", (m) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var content = m.content.toLowerCase();
                if (state == "init") {
                    if (firstPick.includes(content)) {
                        this.blueTeam.push(this.players[1]);
                        this.redTeam.push(this.players[0]);
                        captains.cap1.team = "redTeam";
                        captains.cap2.team = "blueTeam";
                        yield this.awaitResponse(captains, available, players, "cap2");
                        collecter.stop();
                    }
                    else if (secondPick.includes(content)) {
                        this.redTeam.push(this.players[1]);
                        this.blueTeam.push(this.players[0]);
                        captains.cap2.team = "redTeam";
                        captains.cap1.team = "blueTeam";
                        yield this.awaitResponse(captains, available, players, "cap1");
                        collecter.stop();
                    }
                }
                else if (state == "cap1" || state == "cap2") {
                    if (available.has(content)) {
                        let index = (+content) - 1;
                        let team = captains[state].team;
                        this[team].push(players[index]);
                        available.delete(content);
                        if (available.size % 2 == 0) {
                            yield this.awaitResponse(captains, available, players, state);
                        }
                        else if (state == "cap1") {
                            yield this.awaitResponse(captains, available, players, "cap2");
                        }
                        else if (state == "cap2") {
                            yield this.awaitResponse(captains, available, players, "cap1");
                        }
                        collecter.stop();
                    }
                }
            }));
        });
    }
}
exports.Game = Game;
//# sourceMappingURL=index.js.map