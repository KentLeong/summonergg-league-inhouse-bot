"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscordAPI = void 0;
const tslib_1 = require("tslib");
const modules_1 = require("../../modules");
const __1 = require("../../");
const riot_api_1 = require("@summonergg/riot-api");
const league_inhouse_lobby_client_1 = require("@summonergg/league-inhouse-lobby-client");
const game_1 = require("../game");
const randomatic_1 = tslib_1.__importDefault(require("randomatic"));
const chalk_logging_1 = tslib_1.__importDefault(require("chalk-logging"));
class DiscordAPI {
    constructor(opt) {
        var _a, _b;
        this.opt = opt;
        // handle if options is either a message or client
        if (opt === null || opt === void 0 ? void 0 : opt.msg) {
            this.msg = opt.msg;
            this.discordId = this.msg.author.id;
            this.args = (_a = opt.msg) === null || _a === void 0 ? void 0 : _a.args;
            this.guild = this.msg.guild;
            this.server = this.msg.server;
            this.channel = (_b = this.msg.channel) === null || _b === void 0 ? void 0 : _b.id;
            this.clientType = {
                msg: this.msg
            };
            this.res = modules_1.translate(this.msg, "discord");
        }
        else if (opt === null || opt === void 0 ? void 0 : opt.client) {
            this.client = opt.client;
        }
        else {
            throw Error("No option was selected");
        }
    }
    signupValid() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                // check if region is empty
                var region = (_a = this.args) === null || _a === void 0 ? void 0 : _a.shift();
                if (!region)
                    return reject(this.res(200, { region: region }));
                this.region = region;
                // check if region is valid
                if (!Object.keys(modules_1.regions).includes(region.toLowerCase()))
                    reject(this.res(201));
                // get name
                var name = this.args.join(" ");
                if (!name)
                    return reject(this.res(202));
                this.name = name;
                // check if name is more than 16 characters
                if (name.length > 16)
                    return reject(this.res(203));
                resolve(true);
            }));
        });
    }
    summonerTaken() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // check if summoner exists
                var summoner = yield riot_api_1.Summoner.get({ name: this.name, region: this.region });
                if (!summoner)
                    return reject(this.res(204, { name: this.name }));
                this.summoner = summoner;
                // check if summoner is already in use
                if (this.msg) {
                    var user = yield __1.User.getBySummonerId({ id: summoner.id, region: this.msg.server.region }, this.msg);
                }
                if (user)
                    return reject(this.res(205, { name: summoner.name }));
                resolve(true);
            }));
        });
    }
    createToken() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // check if token exists
                var token = yield __1.Token.findOne({ discordId: this.discordId });
                if (!token && this.msg) {
                    token = yield __1.Token.new({
                        msg: this.msg,
                        discordId: this.msg.member.id,
                        summonerId: this.summoner.id,
                        region: this.region
                    });
                    yield token.generateNew(this.summoner.profileIconId);
                }
                else if (!token && this.client) {
                    token = yield __1.Token.new({
                        discordId: this.discordId,
                        summonerId: this.summoner.id,
                        region: this.region
                    });
                }
                else {
                    token.region = this.region;
                    token.summonerId = this.summoner.id;
                    yield token.generateNew(this.summoner.profileIconId);
                }
                this.res(300, { token: token, summoner: this.summoner });
                resolve();
            }));
        });
    }
    getToken() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var token = yield __1.Token.findOne({
                    discordId: this.discordId
                }, this.clientType);
                if (!token)
                    return reject(this.res(206));
                resolve(token);
            }));
        });
    }
    compareIcons(summoner, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (summoner.profileIconId != token.profileIconId)
                    return reject(this.res(207));
                resolve(true);
            }));
        });
    }
    findOrCreateUser() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var user = yield __1.User.findOne({
                    discordId: this.discordId
                }, this.clientType);
                if (!user) {
                    user = yield __1.User.new({
                        discordId: this.discordId
                    }, this.clientType);
                    this.msg.member.roles.add(this.msg.server.roles.member);
                }
                this.user = user;
                resolve(user);
            }));
        });
    }
    findUser(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var user = yield __1.User.findOne({
                    discordId: this.discordId
                }, this.clientType);
                if (!user)
                    reject(this.res(208));
                if ((options === null || options === void 0 ? void 0 : options.includes("hasSummoner")) && !user.accounts.lol[0])
                    return reject(this.res(211));
                if (options === null || options === void 0 ? void 0 : options.includes("isNotInGame")) {
                    var inGame = yield user.isInGame();
                    if (inGame)
                        return reject(this.res(213));
                }
                this.user = user;
                resolve(user);
            }));
        });
    }
    findGame(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                var game = yield game_1.Game.findOne({
                    server: (_a = this.msg.guild.id) !== null && _a !== void 0 ? _a : options.server,
                    channel: (_b = this.msg.channel.id) !== null && _b !== void 0 ? _b : options.channel,
                    state: "lobby" !== null && "lobby" !== void 0 ? "lobby" : options.state
                }, this.clientType);
                if (!game)
                    return reject(this.res(209));
                resolve(game);
            }));
        });
    }
    hostGame(host, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // check if channel is a valid channel
                if (!this.server.channels.hosts.includes(this.channel))
                    return reject(this.res(215));
                // check if game is already being hosted
                var gameExists = yield game_1.Game.findOne({
                    server: this.server.id,
                    channel: this.channel
                }, this.clientType);
                if (gameExists)
                    return reject(this.res(214));
                // try to connect to a lobby bot
                var name = randomatic_1.default("aA0", 5);
                var password = randomatic_1.default("aA0", 10);
                try {
                    var bot = yield league_inhouse_lobby_client_1.LobbyBot.connect(this.msg.server.region.toUpperCase());
                }
                catch (err) {
                    chalk_logging_1.default.error(err);
                }
                if (!bot)
                    return reject(this.res(210));
                yield bot.createLobby({
                    map: "11",
                    mode: "6",
                    teamSize: 5,
                    id: name,
                    password: password
                });
                host.ready = false;
                var player = {
                    account: host.accounts.lol[0],
                    discordId: host.discordId,
                    ready: false,
                    roles: host.roles.lol,
                    gold: host.gold,
                    level: host.level,
                    experience: host.experience
                };
                let data = yield bot.getSummoner(player.account.name);
                yield bot.invitePlayer(data.summonerId);
                var game = yield game_1.Game.new({
                    host: host.discordId,
                    bot: bot.socket.name,
                    name: name,
                    players: [player],
                    channel: this.channel,
                    server: this.guild.id
                }, this.clientType);
                bot.disconnect();
                if (!game)
                    return reject(this.res(212));
                resolve(game);
            }));
        });
    }
}
exports.DiscordAPI = DiscordAPI;
//# sourceMappingURL=index.js.map